<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEIO DIARY - ボクのバスケ日記</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              // ★★★ 葵ちゃんが配色を調整した部分（イメージ：爽やかな水色のユニフォームと制服） ★★★
              'main-color': '#E0F7FA',       // 淡い青 (非常に明るい水色 - Clean Aqua)
              'accent-color': '#FF7F50',     // 情熱のアクセント (コーラル - そのまま維持)
              'dark-color': '#00AEEF',       // 濃い青 (クリアで鮮やかなブルー - Uniform Blue)
              'owner-pink': '#EC4899',       // オーナーモードのピンク (維持)
              // ★★★ 調整ここまで ★★★
            },
            // hover:shadow-3xl が使われているためカスタムシャドウを定義
            boxShadow: {
              '3xl': '0 35px 60px -15px rgba(0, 0, 0, 0.3)',
            }
          }
        }
      }
    </script>

</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel"> 
        // 外部ファイルから読み込まれるはずのグローバル変数を定義
        // ★★★ 注：Firebaseを使用するには、ここに実際のFirebaseプロジェクト設定が必要です ★★★
        const __firebase_config = JSON.stringify({}); // 設定がない場合は空のJSON
        const __initial_auth_token = null; 
        const __app_id = 'seio-asuka-diary'; 

        // ----------------------------------------------------
        // --- [ 新規 テキスト ドキュメント.txt の内容をペースト ] ---
        // ----------------------------------------------------

        // から export default App; まで、すべてのコードをここに挿入

        // --- Firebase関連のインポート（モジュールではないため、ここではimport/exportを削除または調整） ---
        // Babelはimport/exportを変換するため、ここでは元の記述を残します。
        import React, { useState, useEffect, useMemo, useCallback } from 'react';
        import { initializeApp } from 'firebase/app';
        import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
        import { 
          getFirestore, doc, onSnapshot, setDoc, setLogLevel
        } from 'firebase/firestore';
        // Tailwind CSS is assumed to be available.

        // --- [ 1. Firebase/Firestore の初期設定とインポート ] ---
        // Firestoreのログレベルを設定 (デバッグ用)
        setLogLevel('debug');
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ?
        __initial_auth_token : null; 
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        let db, auth;
        let isMockMode = false; // ★★★ なびが追記した行

        // 設定がある場合のみFirebaseを初期化
        if (Object.keys(firebaseConfig).length > 0) {
          try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
          } catch (e) {
            console.error("🚨 Firebase Initialization Error:", e);
            isMockMode = true; // ★★★ なびが追記した行
          }
        } else {
            console.warn("⚠️ Firebase config not found. Running in mock data mode.");
            isMockMode = true; // ★★★ なびが追記した行
        }

        // --- [ 1.5. モックデータ定義（ローカル実行用） ] --- // ★★★ なびが追記したセクション
        const MOCK_DATA = {
            [formatDate(new Date())]: { // 今日
                title: "【モック】強豪校との練習試合！",
                content: "今日は Firebase に接続できなかったため、このモックデータが表示されています。ローカルでは保存はできませんが、UIの動作は確認できます！\n\nバスケの練習はデージちばったさーね！次の試合も勝つさー！",
                mood: "最高",
                updatedAt: new Date(),
                createdAt: new Date(),
            },
            "2025-10-17": { // 以前の会話で出た明日香ちゃんの設定日
                title: "【モック】ボクの一人称は「ボク」だよ。",
                content: "この日は、ボクの設定が完成した日だよ。ボクの一人称は「ボク」って、デージ重要なはずよ。",
                mood: "普通",
                updatedAt: new Date(),
                createdAt: new Date(),
            }
            // 他の日付のモックデータもここに追加できます
        };
        // --- [ 2. ユーティリティ関数と定数 ] ---
        // （ここは変更なし）
        
        // 日付を 'YYYY-MM-DD' 形式にフォーマット
        const formatDate = (date) => {
          if (!date) return '';
          const d = date instanceof Date ? date : new Date(date);
          let month = '' + (d.getMonth() + 1);
          let day = '' + d.getDate();
          let year = d.getFullYear();

          if (month.length < 2) month = '0' + month;
          if (day.length < 2) day = '0' + day;

          return [year, month, day].join('-');
        };

        // ゲスト名とオーナーメール（仮）
        const GUEST_NAME = 'Guest';
        const OWNER_EMAIL = 'Asuka'; // オーナーの名前（明日香ちゃん）

        // 気分に応じた色とアイコン
        const MOOD_MAP = {
            '最高': { color: 'bg-red-500', icon: '🔥' },
            '良い': { color: 'bg-green-500', icon: '😊' },
            '普通': { color: 'bg-yellow-500', icon: '😐' },
            '悪い': { color: 'bg-blue-500', icon: '😔' },
            '最悪': { color: 'bg-gray-500', icon: '😭' },
        };
        
        // 年月を取得（表示用）
        const getMonthYearString = (year, month) => {
            return `${year}年 ${month + 1}月`;
        };

        // --- [ 3. コンポーネント群 ] ---

        // ヘッダーコンポーネント
        const Header = ({ userName, setUserName, userId }) => {
            // userIdが長すぎる場合は一部を省略して表示
            const displayUserId = userId ? `${userId.substring(0, 8)}...` : 'N/A';
            
            return (
                <header className="fixed top-0 left-0 right-0 bg-dark-color text-white shadow-lg z-10">
                    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3 flex justify-between items-center">
                        <div className="flex items-center space-x-3">
                            {/* タイトル：ボクの一人称を強調 */}
                            <h1 className="text-2xl font-extrabold tracking-tight">
                                <span className="text-accent-color">ボク</span>のバスケ日記
                            </h1>
                        </div>
                        <div className="flex items-center space-x-4 text-sm">
                            <span className="hidden sm:inline">
                                ユーザーID: <span className="font-mono text-xs">{userId || 'Loading...'}</span>
                            </span>
                            {/* ユーザー名表示/切り替え（ダミー） */}
                            <div className="relative group">
                                <span className={`cursor-pointer font-semibold ${userName === OWNER_EMAIL ? 'text-owner-pink' : 'text-gray-300'}`}>
                                    {userName === OWNER_EMAIL ? '🏀 明日香 (オーナー)' : '👤 ゲスト'}
                                </span>
                                {/* ドロップダウン風の切替UI */}
                                <div className="absolute right-0 mt-2 w-32 bg-white rounded-md shadow-xl opacity-0 group-hover:opacity-100 transition-opacity duration-300 z-20">
                                    <button 
                                        onClick={() => setUserName(OWNER_EMAIL)} 
                                        className="block px-4 py-2 text-sm text-owner-pink hover:bg-gray-100 w-full text-left rounded-t-md"
                                    >
                                        オーナーに切替
                                    </button>
                                    <button 
                                        onClick={() => setUserName(GUEST_NAME)} 
                                        className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left rounded-b-md"
                                    >
                                        ゲストに切替
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </header>
            );
        };
        
        // ヒーローセクション（単なる視覚的要素）
        const HeroSection = () => (
             <section className="bg-main-color pt-20 pb-16">
                <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
                    <h2 className="text-4xl font-extrabold text-dark-color mb-2">SEIO DIARY</h2>
                    <p className="text-lg text-dark-color/80">
                        努力、汗、そして成長の記録。ボクの青春の軌跡を綴る。
                    </p>
                </div>
            </section>
        );

        // フッターコンポーネント
        const Footer = () => (
            <footer className="bg-gray-100 text-gray-600 py-4 text-center text-xs">
                &copy; 2025 SEIO DIARY - Designed with {MOOD_MAP.最高.icon} by Aoi Amano
            </footer>
        );

        // --- [ 3.1 閲覧モードコンポーネント ] ---

        const renderDiaryViewer = (currentDiary, loading, isOwner, setIsEditingMode) => {
            if (loading) {
                return <p className="text-center text-gray-500 py-10">日記を読み込み中... ⏳</p>;
            }

            if (!currentDiary) {
                return (
                    <div className="text-center py-10">
                        <p className="text-gray-500 mb-4">この日は何も書かれていませんでした。</p>
                        {isOwner && (
                            <button 
                                onClick={() => setIsEditingMode(true)}
                                className="bg-owner-pink text-white font-semibold py-2 px-6 rounded-full shadow-md hover:bg-pink-700 transition duration-300 transform hover:scale-105"
                            >
                                新しく書く
                            </button>
                        )}
                    </div>
                );
            }

            const mood = MOOD_MAP[currentDiary.mood] || MOOD_MAP.普通;
            
            return (
                <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-xl border border-gray-100">
                    <div className="flex justify-between items-start mb-4">
                        <h2 className="text-3xl font-bold text-dark-color">
                            {currentDiary.title}
                        </h2>
                        {isOwner && (
                            <button 
                                onClick={() => setIsEditingMode(true)}
                                className="text-sm bg-dark-color text-white py-1 px-3 rounded-full hover:bg-dark-color/80 transition duration-150"
                            >
                                編集
                            </button>
                        )}
                    </div>

                    <div className="flex items-center space-x-4 mb-6 text-gray-600 text-sm">
                        <span className={`px-3 py-1 text-white text-xs font-semibold rounded-full ${mood.color}`}>
                            {mood.icon} {currentDiary.mood}
                        </span>
                        <span>最終更新: {currentDiary.updatedAt instanceof Date ? currentDiary.updatedAt.toLocaleString() : new Date(currentDiary.updatedAt.toDate()).toLocaleString()}</span>
                    </div>

                    <div className="prose max-w-none leading-relaxed whitespace-pre-wrap">
                        {/* プレースホルダーで改行を保持 */}
                        <p className="text-gray-700 text-base">{currentDiary.content}</p>
                    </div>
                </div>
            );
        };
        
        // --- [ 3.2 編集モードコンポーネント ] ---

        const renderDiaryEditor = (
            editorTitle, setEditorTitle, editorContent, setEditorContent, 
            editorMood, setEditorMood, isSaving, handleSave, 
            setIsEditingMode, hasUnsavedChanges
        ) => {
            const MOODS = ['最高', '良い', '普通', '悪い', '最悪'];

            return (
                <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-xl border border-owner-pink">
                    <div className="mb-6">
                        <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-1">
                            タイトル
                        </label>
                        <input
                            id="title"
                            type="text"
                            value={editorTitle}
                            onChange={(e) => setEditorTitle(e.target.value)}
                            className="w-full border-2 border-gray-300 rounded-lg p-3 text-lg focus:border-owner-pink focus:ring-owner-pink"
                            placeholder="今日あったことを簡潔に！"
                        />
                    </div>

                    <div className="mb-6">
                        <label htmlFor="mood" className="block text-sm font-medium text-gray-700 mb-1">
                            今日の気分
                        </label>
                        <div className="flex space-x-3">
                            {MOODS.map(mood => (
                                <button
                                    key={mood}
                                    onClick={() => setEditorMood(mood)}
                                    className={`px-4 py-2 text-sm font-semibold rounded-full transition duration-150 ease-in-out ${
                                        editorMood === mood 
                                            ? `${MOOD_MAP[mood].color} text-white shadow-lg` 
                                            : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                                    }`}
                                >
                                    {MOOD_MAP[mood].icon} {mood}
                                </button>
                            ))}
                        </div>
                    </div>

                    <div className="mb-6">
                        <label htmlFor="content" className="block text-sm font-medium text-gray-700 mb-1">
                            日記の内容（ボクの正直な気持ちを！）
                        </label>
                        <textarea
                            id="content"
                            rows="10"
                            value={editorContent}
                            onChange={(e) => setEditorContent(e.target.value)}
                            className="w-full border-2 border-gray-300 rounded-lg p-3 focus:border-owner-pink focus:ring-owner-pink"
                            placeholder="今日の練習、試合、友達との出来事など、なんでも書いてね。"
                        ></textarea>
                    </div>

                    <div className="flex justify-end space-x-3">
                        <button 
                            onClick={() => setIsEditingMode(false)}
                            className="px-6 py-2 border border-gray-300 text-gray-700 rounded-full hover:bg-gray-100 transition duration-150"
                            disabled={isSaving}
                        >
                            {hasUnsavedChanges ? '中止 (破棄)' : '戻る'}
                        </button>
                        <button 
                            onClick={handleSave}
                            className={`px-6 py-2 font-bold rounded-full transition duration-300 transform ${
                                isSaving 
                                    ? 'bg-gray-400 text-white cursor-not-allowed' 
                                    : 'bg-owner-pink text-white shadow-md hover:bg-pink-700 hover:scale-105'
                            }`}
                            disabled={isSaving}
                        >
                            {isSaving ? '保存中...' : '保存して完了'}
                        </button>
                    </div>
                </div>
            );
        };


        // 日記の表示とカレンダーUIを統合したメインセクション
        const DiaryCalendarSection = ({ userId, isOwner, isEditingMode, setIsEditingMode }) => {
          // ... State定義（変更なし）
          const today = useMemo(() => new Date(), []);
          const [selectedDate, setSelectedDate] = useState(today);
          const [currentDiary, setCurrentDiary] = useState(null);
          const [loading, setLoading] = useState(true);
          const [currentMonth, setCurrentMonth] = useState(today.getMonth());
          const [currentYear, setCurrentYear] = useState(today.getFullYear());
          
          // 編集フォーム用のState
          const [editorTitle, setEditorTitle] = useState('');
          const [editorContent, setEditorContent] = useState('');
          const [editorMood, setEditorMood] = useState('普通');
          const [isSaving, setIsSaving] = useState(false);
          const [saveMessage, setSaveMessage] = useState('');
          // 編集中のデータが未保存かどうかを判定するState (UX改善のため)
          const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false); 

          // --- [ A. Firestoreデータ取得ロジック（修正） ] ---
          useEffect(() => {
            // 認証待ち、またはDB未初期化の場合は早期リターン
            if (!db || !userId) {
                // ★★★ ここからローカル対応の修正 ★★★
                if (isMockMode) {
                    setLoading(false);
                    const docId = formatDate(selectedDate);
                    const data = MOCK_DATA[docId];
                    setCurrentDiary(data || null);
                    
                    if (isOwner) {
                        setEditorTitle(data?.title || '');
                        setEditorContent(data?.content || '');
                        setEditorMood(data?.mood || '普通');
                        setSaveMessage('⚠️ モックデータ表示中です。保存はできません。');
                        setIsEditingMode(false); // モックモードでは閲覧のみ
                    }
                    return;
                }
                // ★★★ ここまでローカル対応の修正 ★★★

                setLoading(false);
                if (isOwner) {
                    setSaveMessage('認証を待っています...');
                }
                return; 
            }

            setLoading(true);
            const docId = formatDate(selectedDate); 
            // 
            // プライベートデータパス: artifacts/{appId}/users/{userId}/diaries/{日付}
            const docRef = doc(db, `artifacts/${appId}/users/${userId}/diaries`, docId);

            
            const unsubscribeSnapshot = onSnapshot(docRef, (docSnap) => {
              let data = null;
              if (docSnap.exists()) {
                data = docSnap.data();
              }
              setCurrentDiary(data ? { id: docSnap.id, ...data, date: docSnap.id } : null);

              // オーナーの場合、フォームにデータを流し込む（閲覧モードでも同期）
              if (isOwner) {
                setEditorTitle(data?.title || '');
          
                setEditorContent(data?.content || '');
                setEditorMood(data?.mood || '普通');
                setSaveMessage(data ? 'この日記を編集できます。' : '未記入です。新しい記事を作成できます！');
                setHasUnsavedChanges(false); // データ同期後は変更なしと見なす
              }

              setLoading(false);
            }, (error) => {
              console.error("Firestore Snapshot Error:", error);
              setLoading(false);
            });

            return () => unsubscribeSnapshot();
          }, [userId, selectedDate, isOwner]); 
          
          // 編集内容の変更を監視し、未保存フラグを更新
          // ... （このロジックは変更なし）
          useEffect(() => {
            // 現在のFirestoreデータとエディタの値を比較
            const currentTitle = currentDiary?.title || '';
            const currentContent = currentDiary?.content || '';
            const currentMood = currentDiary?.mood || '普通';

            const isDirty = (
                editorTitle !== currentTitle ||
                editorContent !== currentContent ||
                editorMood !== currentMood
            );
            
            // ロード中でない、かつオーナーの場合のみフラグを更新
            if (!loading && 
            isOwner) {
                setHasUnsavedChanges(isDirty);
            }
          }, [editorTitle, editorContent, editorMood, currentDiary, loading, isOwner]);
        // --- [ B. 日記保存ロジック (オーナー専用)（修正） ] ---
          const handleSave = async () => {
              // ★★★ ここからローカル対応の修正 ★★★
              if (isMockMode) {
                  setSaveMessage('🚨 モックモードでは保存できません。サーバーにアップロードするか、Firebaseを設定してください。');
                  return;
              }
              // ★★★ ここまでローカル対応の修正 ★★★
              
              if (!db || !auth || !userId) {
                  setSaveMessage('🚨 データベース接続エラー、または未認証です。');
                  return;
              }
              if (!editorTitle.trim() && !editorContent.trim()) {
                  setSaveMessage('🚨 タイトルか内容のどちらかを入力してください。');
                  return;
              }

              setIsSaving(true);
              setSaveMessage('✨ 保存中... サーバーへデータを送信しています。');

              const docId = formatDate(selectedDate);
              const docRef = doc(db, `artifacts/${appId}/users/${userId}/diaries`, docId);
              
              try {
                  // setDoc with merge: trueで、フィールドを上書きまたは新規作成
                  await setDoc(docRef, {
                      title: editorTitle,
                      content: editorContent,
                      mood: editorMood,
                      updatedAt: new Date(),
              
                      // 新規作成時のみcreatedAtを設定 (既存のcreatedAtはFirestoreのスナップショットから取得しているため、ここでは上書きしない)
                      createdAt: currentDiary?.createdAt || new Date(), 
                  }, { merge: true });
                  setSaveMessage('✅ ボクの日記の保存が完了しました！');
                  setHasUnsavedChanges(false); // 保存完了
                  // 保存成功後、自動的に閲覧モードに戻る
                  setIsEditingMode(false);
              } catch (error) {
                  console.error("Firestore Save Error:", error);
                  setSaveMessage(`🔥 保存失敗: エラーコード ${error.code}が発生しました。`);
              } finally {
                  setIsSaving(false);
              }
          };
        // 未保存の変更がある場合の確認ハンドラ
          // ... （このロジックは変更なし）
          const handleUnsavedChangeCheck = (callback) => {
              // オーナーかつ編集中で未保存の変更がある場合
              if (isOwner && isEditingMode && hasUnsavedChanges) {
                  // カスタムモーダルの代わりに、一時的なUIメッセージでユーザーに確認を促す
                  setSaveMessage('🚨 未保存の変更があります！中止ボタンで破棄するか、保存ボタンで保存してください。');
        // 変更をキャンセルしたことを伝えるため、falseを返す（カレンダー操作を中止）
                  return false;
              }
              // 変更がない、またはゲストの場合はそのまま実行
              callback();
        // 変更があった場合はすでにfalseが返っているので、成功時はtrueを返す（カレンダー操作を実行）
              return true;
          };
        // --- [ C. カレンダーUIロジック ] ---
          const getFirstDayOfMonth = (year, month) => new Date(year, month, 1);
          const getDaysInMonth = (year, month) => new Date(year, month + 1, 0).getDate();
          
          const getCalendarDays = (year, month) => {
              const firstDay = getFirstDayOfMonth(year, month).getDay(); // 0 (Sun) to 6 (Sat)
              const daysInMonth = getDaysInMonth(year, month);
              
              const calendarDays = [];
              
              // 前月の日付のプレースホルダー
              for (let i = 0; i < firstDay; i++) {
                  calendarDays.push({ day: null, currentMonth: false });
              }

              // 今月の日付
              for (let i = 1; i <= daysInMonth; i++) {
                  // Firestoreから取得したデータに、この日付の日記が存在するかどうかをチェック
                  // NOTE: これは現在のところ、selectedDate の日記データしか取得していないため、
                  // 正確な月全体のデータ有無チェックは、月全体のデータ構造を別途 Firestore から取得する必要があります。
                  // 今回はシンプルに、単に日付を表示するのみに留めます。
                  calendarDays.push({ day: i, currentMonth: true });
              }
              
              return calendarDays;
          };

          const handlePrevMonth = () => {
              if (handleUnsavedChangeCheck(() => {})) {
                  setCurrentMonth(m => {
                      if (m === 0) {
                          setCurrentYear(y => y - 1);
                          return 11;
                      }
                      return m - 1;
                  });
              }
          };

          const handleNextMonth = () => {
              if (handleUnsavedChangeCheck(() => {})) {
                  setCurrentMonth(m => {
                      if (m === 11) {
                          setCurrentYear(y => y + 1);
                          return 0;
                      }
                      return m + 1;
                  });
              }
          };

          const handleDateClick = (day) => {
              const newDate = new Date(currentYear, currentMonth, day);
              
              // 日記の変更がある場合、移動をブロックし警告メッセージを表示
              if (!handleUnsavedChangeCheck(() => {})) {
                return;
              }
              
              setSelectedDate(newDate);
              // 日付が変わったら、編集モードを自動的に解除
              setIsEditingMode(false);
          };
          
          const isSelected = (day) => {
              return selectedDate && day === selectedDate.getDate() && currentMonth === selectedDate.getMonth() && currentYear === selectedDate.getFullYear();
          };
          
          const isToday = (day) => {
              return day === today.getDate() && currentMonth === today.getMonth() && currentYear === today.getFullYear();
          };

          // --- [ D. レンダリング ] ---
          
          // モバイル用の固定ボタン
          const FixedMobileButton = () => {
              if (!isOwner) return null;
              
              const text = isEditingMode 
                ? (hasUnsavedChanges ? '保存する' : '戻る')
                : (currentDiary ? '編集する' : '新しく書く');
                
              const bgColor = isEditingMode
                ? (hasUnsavedChanges ? 'bg-owner-pink hover:bg-pink-700 shadow-xl' : 'bg-gray-400 hover:bg-gray-500 shadow-md')
                : 'bg-dark-color hover:bg-dark-color/80 shadow-xl';
              
              const handleClick = () => {
                  if (isEditingMode) {
                      if (hasUnsavedChanges) {
                          handleSave();
                      } else {
                          setIsEditingMode(false);
                      }
                  } else {
                      setIsEditingMode(true);
                  }
              };

              return (
                  <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 p-3 lg:hidden z-10">
                      <button 
                          onClick={handleClick}
                          className={`w-full text-white font-bold py-3 rounded-full transition duration-300 transform ${bgColor}`}
                          disabled={isSaving}
                      >
                          {isSaving ? '保存中...' : text}
                      </button>
                  </div>
              );
          };

          return (
              <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-10 grid lg:grid-cols-3 gap-8">
                  
                  {/* カレンダー＆コントロール (左側) */}
                  <div className="lg:col-span-1 bg-white p-6 rounded-2xl shadow-xl border border-main-color h-fit sticky top-20">
                      <div className="flex justify-between items-center mb-4">
                          <button onClick={handlePrevMonth} className="text-dark-color hover:text-dark-color/70">
                              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 19l-7-7 7-7"></path></svg>
                          </button>
                          <h3 className="text-xl font-bold text-dark-color">
                              {getMonthYearString(currentYear, currentMonth)}
                          </h3>
                          <button onClick={handleNextMonth} className="text-dark-color hover:text-dark-color/70">
                              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7"></path></svg>
                          </button>
                      </div>

                      <div className="grid grid-cols-7 text-center text-sm font-semibold text-gray-500 border-b pb-2 mb-2">
                          <div>日</div><div>月</div><div>火</div><div>水</div><div>木</div><div>金</div><div>土</div>
                      </div>

                      <div className="grid grid-cols-7 text-center">
                          {getCalendarDays(currentYear, currentMonth).map((item, index) => {
                              const day = item.day;
                              const current = item.currentMonth;
                              const isSel = isSelected(day);
                              const isTod = isToday(day);
                              
                              let dayClasses = "p-2 rounded-full cursor-pointer transition duration-150";

                              if (day === null || !current) {
                                  dayClasses = "p-2 text-gray-300 cursor-default";
                              } else {
                                  if (isSel) {
                                      // 選択中の日付 (濃い青)
                                      dayClasses += " bg-dark-color text-white font-bold shadow-md hover:bg-dark-color/90";
                                  } else if (isTod) {
                                      // 今日の日付 (アクセントカラー)
                                      dayClasses += " border-2 border-accent-color text-dark-color font-semibold hover:bg-main-color/50";
                                  } else {
                                      // 通常の日付
                                      dayClasses += " text-gray-700 hover:bg-main-color/70";
                                  }
                              }

                              return (
                                  <div key={index} className="p-1">
                                      <span 
                                          className={dayClasses}
                                          onClick={() => day && current && handleDateClick(day)}
                                      >
                                          {day || ''}
                                      </span>
                                  </div>
                              );
                          })}
                      </div>
                      
                      {/* メッセージ表示エリア */}
                      <p className="mt-6 text-xs text-center text-gray-600 h-5 whitespace-nowrap overflow-hidden">
                          {saveMessage}
                      </p>
                  </div>
                  
                  {/* 日記表示/編集エリア (右側) */}
                  <div className="lg:col-span-2">
                      <div className="mb-4 text-center">
                          <h2 className="text-2xl font-semibold text-gray-700">
                              {selectedDate.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'short' })}
                          </h2>
                      </div>
                      
                      {/* 日記コンポーネントのレンダリング */}
                      {isOwner && isEditingMode 
                        ? renderDiaryEditor(
                            editorTitle, setEditorTitle, 
                            editorContent, setEditorContent, 
                            editorMood, setEditorMood, 
                            isSaving, handleSave, 
                            setIsEditingMode, hasUnsavedChanges
                          )
                        : renderDiaryViewer(currentDiary, loading, isOwner, setIsEditingMode)}
                  </div>
                  
                  {/* モバイルボタンをここに入れる */}
                  <FixedMobileButton />
              </div>
          );
        };
          
        // --- [ 4. メイン App コンポーネント ] ---

        const App = () => {
            // ... (Appコンポーネント内は変更なし)
            const [userId, setUserId] = useState(null);
            const [userName, setUserName] = useState(GUEST_NAME); 
            // 編集モードの状態をトップレベルで管理
            const [isEditingMode, setIsEditingMode] = useState(false);
            const isOwner = userName === OWNER_EMAIL;

            // Firebase認証処理
            const signIn = useCallback(async () => {
                if (!auth) return;
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                        console.log("Firebase: Signed in with Custom Token.");
                   
                    } else {
                        await signInAnonymously(auth);
                        console.log("Firebase: Signed in Anonymously.");
                    }
                } catch (error) {
                    console.error("🚨 Authentication failed during sign-in attempt:", error);
                }
            }, []);
        // 認証状態の監視と処理
            useEffect(() => {
                if (!auth) { // ★★★ モックモード対応：authオブジェクトがない場合は処理しない
                  if (isMockMode) {
                      setUserId('MOCK_USER_ID'); // ダミーのIDを設定
                      return;
                  }
                  return; 
                }

                const unsubscribeAuth = onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        // Auth IDを短縮せずに全て表示する
                        setUserId(user.uid); 
                        // ★★★ 修正箇所: 文字列を一行に結合 ★★★
                        console.log("Firebase: Auth state changed. User ID set:", user.uid);
                    } else {
                        // ユーザーがいない場合はサインインを試みる
                        await signIn();
                    }
                });

                return () => unsubscribeAuth();
            }, [auth, signIn]);
        // モバイル用固定ボタンの表示/非表示フラグ
            const showFixedButton = isOwner; 
            
            return (
                <div className="min-h-screen antialiased text-gray-900 font-sans">
                    <Header 
                        userName={userName} 
                        setUserName={setUserName} 
                        userId={userId} 
                    />
          
                    {/* pt-16でヘッダー下のスペースを確保。モバイルの固定フッターのpb-20を適用/解除 */}
                    <main className={`pt-16 ${showFixedButton && 'pb-20 lg:pb-0'}`}> 
                        <HeroSection />
                        <DiaryCalendarSection 
                            userId={userId} 
                            isOwner={isOwner} 
                            isEditingMode={isEditingMode} 
                            setIsEditingMode={setIsEditingMode} 
                        />
                    </main>
                    <Footer />
                </div>
           
              );
            };

        // ----------------------------------------------------
        // --- [ 6. アプリの描画 ] ---
        // ----------------------------------------------------
        
        // AppコンポーネントをDOMにレンダリングする
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
        
    </script>
</body>
</html>